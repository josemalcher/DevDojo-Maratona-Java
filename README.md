# Maratona Java - O maior curso Java em português.

[Canal Youtube DevDojo](https://www.youtube.com/playlist?list=PL62G310vn6nHrMr1tFLNOYP_c73m6nAzL)

Adição de Resumos das matérias do Livro do Deitel: Java Como Programar ed.10º.

---

### <a name="indice">Índice</a>

- [Aula 00: Introdução ao curso](#parte1)
- [Aula 01: Como JAVA funciona](#parte2)
- [Aula 02: Como instalar JAVA no windows](#parte3)
- [Aula 03: Executando o processo de compilação manualmente](#parte4)
- [Aula 04: Download do ambiente de desenvolvimento](#parte5)
- [Aula 05: Tipos primitivos, convenções de código e comentários](#parte6)
- [Aula 06: Continuação tipos primitivos, exercício e operadores](#parte7)
- [Aula 07: Operador resto e operadores de comparação](#parte8)
- [Aula 08: Operadores Lógicos](#parte9)
- [Aula 09: Operadores de Atribuição](#parte10)
- [Aula 10: Controle de fluxo if, else if e else](#parte11)
- [Aula 11: Controle de fluxo: Tabela verdade e mais.](#parte12)
- [Aula 12: Controle de fluxo Resolução do exercício if else](#parte13)
- [Aula 13: Controle de fluxo switch e exercícios](#parte14)
- [Aula 14: Controle de fluxo - Solução do exercício](#parte15)
- [Aula 15: Controle de fluxo for, while, do while](#parte16)
- [Aula 16: Exercício estrutura de repetição](#parte17)
- [Aula 17: Comando break and continue](#parte18)
- [Aula 18: Arrays parte 1](#parte19)
- [Aula 19: Arrays parte 2](#parte20)
- [Aula 20: Arrays parte 3 foreach](#parte21)
- [Aula 21: Arrays parte 4 arrays multidimencionais](#parte22)
- [Aula 22: Arrays parte 5 arrays multidimencionais](#parte23)
- [Aula 23: Introdução a pacotes](#parte24)
- [Aula 24: Introdução a classes parte 1](#parte25)
- [Aula 25: Introdução a classes parte 2 + exercício](#parte26)
- [Aula 26: Solução do exercício introdução a classes](#parte27)
- [Aula 27: Introdução a métodos](#parte28)
- [Aula 28: Métodos com parâmetros](#parte29)
- [Aula 29: Retorno de métodos parte 01](#parte30)
- [Aula 30: Retorno de métodos parte 02](#parte31)
- [Aula 31: Métodos com parâmetros tipo reference pt 01](#parte32)
- [Aula 32: Passagem de objeto como parâmetro e this pt 02](#parte33)
- [Aula 33: Passagem de parâmetros varargs](#parte34)
- [Aula 34: Introdução a UML](#parte35)
- [Aula 35: Exercício sobre métodos](#parte36)
- [Aula 36: Modificador de acesso private, get e set pt 01](#parte37)
- [Aula 37: Modificador de acesso private, get e set pt 02](#parte38)
- [Aula 38: Sobrecarga de métodos](#parte39)
- [Aula 39: Construtores e sobrecarga de construtores pt 01](#parte40)
- [Aula 40: Construtores e sobrecarga de construtores pt 02](#parte41)
- [Aula 41: Blocos de inicialização](#parte42)
- [Aula 42: Modificador static](#parte43)
- [Aula 43: Métodos Estáticos](#parte44)
- [Aula 44: Bloco de inicialização](#parte45)
- [Aula 45: UML e Associação de classes](#parte46)
- [Aula 46: Exercício associação pt 01](#parte47)
- [Aula 47: Exercício associação pt 02](#parte48)
- [Aula 48: Exercício associação de classes pt 03](#parte49)
- [Aula 49: Exercício associação pt 04](#parte50)
- [Aula 50: Herança pt 01](#parte51)
- [Aula 51: Herança parte 2 e referência super](#parte52)
- [Aula 52: Herança e Modificador Protected pt 03](#parte53)
- [Aula 53: Herança e construtores pt 04](#parte54)
- [Aula 54: Herança e Sequência de inicialização pt 05](#parte55)
- [Aula 55: Sobrescrita de métodos](#parte56)
- [Aula 56: Modificador Final](#parte57)
- [Aula 57: Enumeração pt 01](#parte58)
- [Aula 58: Enumeração pt 02](#parte59)
- [Aula 59: Enumeração pt 03](#parte60)
- [Aula 60: Classes abstratas pt 01](#parte61)
- [Aula 61: Classes abstratas pt 02](#parte62)
- [Aula 62: Interfaces pt 01](#parte63)
- [Aula 63: Interfaces pt 02](#parte64)
- [Aula 64: Polimorfismo pt 01](#parte65)
- [Aula 65: Polimorfismo pt 02](#parte66)
- [Aula 66: Polimorfismo pt 03](#parte67)
- [Aula 67: Exceptions pt 01](#parte68)
- [Aula 68: Exceptions pt 02](#parte69)
- [Aula 69: Exceptions: Exceções checked pt 03](#parte70)
- [Aula 70: Exceptions: lançamento de exceção pt 04](#parte71)
- [Aula 71: Exceptions: bloco finally pt 05](#parte72)
- [Aula 72: Tratamento de multiplas exceções pt 06](#parte73)
- [Aula 73: Exceptions: Multi-catch pt 07](#parte74)
- [Aula 74 : Exceptions: try-with-resources pt 08](#parte75)
- [Aula 75: Exceptions customizadas pt 09](#parte76)
- [Aula 76: Exceptions e regras para sobrescrita pt 10](#parte77)
- [Aula 77: Assertivas](#parte78)
- [Aula 78: Classes Wrapper pt 01](#parte79)
- [Aula 79: Classes Wrapper pt 02](#parte80)
- [Aula 80: String pt 01](#parte81)
- [Aula 81: String pt 02](#parte82)
- [Aula 82: Performance das Strings](#parte83)
- [Aula 83: StringBuilder and StringBuffer](#parte84)
- [Aula 84: Datas com Date e Calendar](#parte85)
- [Aula 85: Formatação de datas com DateFormat](#parte86)
- [Aula 86: Internacionalização com a classe Locale](#parte87)
- [Aula 87: Formatação de números e moeda com NumberFormat](#parte88)
- [Aula 88: Datas personalizadas com SimpleDateFormat](#parte89)
- [Aula 89: Expressões regulares pt 01](#parte90)
- [Aula 90: Expressões regulares pt 02](#parte91)
- [Aula 91: Expressões regulares pt 03](#parte92)
- [Aula 92: Expressões regulares pt 04](#parte93)
- [Aula 93: Expressões regulares pt 05](#parte94)
- [Aula 94: Expressões regulares pt 06](#parte95)
- [Aula 95: Tokens e Delimitadores com String e Scanner](#parte96)
- [Aula 96: Resource Bundles pt 01](#parte97)
- [Aula 97: Resource Bundles pt 02](#parte98)
- [Aula 98: IO pt 01 Classe File para arquivos](#parte99)
- [Aula 99: IO pt 02 FileWriter e FileReader](#parte101)
- [Aula 100: IO pt 03 BufferedWriter e BufferedReader](#parte102)
- [Aula 101: IO pt 04 Classe File para diretórios](#parte103)
- [Aula 102: IO pt 05 Classe Console](#parte104)
- [Aula 103: NIO pt 01 Introdução as novas classes Path, Paths, Files](#parte105)
- [Aula 104: NIO pt 02 Uso básico das classes Path, Paths, Files](#parte106)
- [Aula 105: NIO pt 03 Normalizando paths](#parte107)
- [Aula 106: NIO pt 04 Resolvendo paths](#parte108)
- [Aula 107: NIO pt 05 Relativizando paths](#parte109)
- [Aula 108: NIO pt 06 BasicFileAttributes e BasicFileAttributeView](#parte110)
- [Aula 109: NIO pt 07 DosFileAttributes e DosFileAttributeView](#parte111)
- [Aula 110: NIO pt 08 PosixFileAttributes e PosixFileAttributeView](#parte112)
- [Aula 111: NIO pt 09 DirectoryStream e SimpleFileVisitor](#parte113)
- [Aula 112: NIO pt 10 PathMacther](#parte114)
- [Aula 113: IO pt 06 InputStream e OutputStream](#parte115)
- [Aula 114: NIO pt 11 Zipando arquivos com Java](#parte116)
- [Aula 115: Serialização](#parte117)
- [Aula 116: Coleções pt 01 método equals()](#parte118)
- [Aula 117: Coleções pt 02 método hashCode](#parte119)
- [Aula 118: Coleções pt 03 Introdução as coleções](#parte120)
- [Aula 119: Coleções pt 04 Lists pt 01](#parte121)
- [Aula 120: Coleções pt 05 Lists pt 02](#parte122)
- [Aula 121: Coleções pt 06 Ordenação de listas com Comparable](#parte123)
- [Aula 122: Coleções pt 07 Ordenação de listas e arrays com Comparator](#parte124)
- [Aula 123: Coleções pt 08 Busca binária em Lists e Arrays](#parte125)
- [Aula 124: Coleções pt 09 Convertendo Arrays em List e List em Arrays](#parte126)
- [Aula 125: Coleções pt 10 Removendo elementos da lista com Iterator](#parte127)
- [Aula 126: Coleções pt 11 Set, HashSet e LinkedHashSet](#parte128)
- [Aula 127: Coleções pt 12 NavigableSet e TreeSet](#parte129)
- [Aula 128: Coleções pt 13 Map, HashMap e LinkedHashMap pt 01](#parte130)
- [Aula 129: Coleções pt 14 Map, HashMap e LinkedHashMap pt 02](#parte131)
- [Aula 130: Coleções pt 15 NavigableMap e TreeMap](#parte132)
- [Aula 131: Coleções pt 16 Queue e PriorityQueue](#parte133)
- [Aula 132: Generics pt 01 O que são Generics](#parte134)
- [Aula 133: Generics pt 02 Wildcard Caracter coringa](#parte135)
- [Aula 134: Generics pt 03 Classes genéricas](#parte136)
- [Aula 135: Generics pt 04 Métodos genéricos](#parte137)
- [Aula 136: Inner Classes pt 01 Classe Interna aninhada](#parte138)
- [Aula 137: Inner Classes pt 02 Classe Interna local](#parte139)
- [Aula 138: Inner Classes pt 03 Classes Anônimas](#parte140)
- [Aula 139: Inner Classes pt 04 Classes Internas Estáticas](#parte141)
- [Aula 140: JBDC pt 01 Instalando o banco de dados MySQL](#parte142)
- [Aula 141: JBDC pt 02 Criando o banco e as tabelas](#parte143)
- [Aula 142: JBDC pt 03 Criando conexão com o banco de dados](#parte144)
- [Aula 143: JBDC pt 04 Inserindo dados no banco com Statement](#parte145)
- [Aula 144: JBDC pt 05 Atualizando e excluindo dados com Statement](#parte146)
- [Aula 145: JBDC pt 06 ResultSet pt 01 - Selecionando registros](#parte147)
- [Aula 146: JBDC pt 07 ResultSet pt 02 - Tipos de ResultSet e metadados](#parte148)
- [Aula 147: JBDC pt 08 ResultSet pt 03 - Métodos para posicionamento do cursor](#parte149)
- [Aula 148: JBDC pt 09 RS pt 04 Atualizando registros através do ResultSet](#parte150)
- [Aula 149: JBDC pt 10 PreparedStatement](#parte151)
- [Aula 150: JBDC pt 11 Procedures e funções no banco com CallableStatement](#parte152)
- [Aula 151: JBDC pt 12 Connected RowSet - JdbcRowSet](#parte153)
- [Aula 152: JBDC pt 13 Disconnected RowSet - CachedRowSet](#parte154)
- [Aula 153: JBDC pt 14 Transações](#parte155)
- [Aula 154: JBDC pt 15 CRUD pt 01](#parte156)
- [Aula 155: JBDC pt 16 CRUD pt 02](#parte157)
- [Aula 156: Threads pt 01 O que são e como criar](#parte158)
- [Aula 157: Thread pt 02 Thread states](#parte159)
- [Aula 158: Threads pt 03 Parando a execução com Sleep, Yield e Join](#parte160)
- [Aula 159: Threads pt 04: Sincronismo de código pt 01](#parte161)
- [Aula 160: Sincronismo de código e Deadlock pt 02](#parte162)
- [Aula 161: Threads pt 06: Interação de Threads com wait, notify e notifyAll](#parte163)
- [Aula 162: Concorrência pt 01: Variáveis atômicas](#parte164)
- [Aula 163: Concorrência pt 02: Lock e ReentrantLock](#parte165)
- [Aula 164: Concorrência pt 03: Conditions](#parte166)
- [Aula 165: Concorrência pt 04 : ReentrantReadWriteLock](#parte167)
- [Aula 166: Concorrência pt 05: CopyOnWriteArrayList](#parte168)
- [Aula 167: Concorrência pt 06: Coleções Concorrentes](#parte169)
- [Aula 168: Concorrência pt 07: Blocking Queues](#parte170)
- [Aula 169: Concorrência pt 08: Executors pt 01 Thread Pools](#parte171)
- [Aula 170: Concorrência pt 09: Executors pt 02 Scheduled Thread Pool](#parte172)
- [Aula 171: Concorrência pt 10: Interface Callable](#parte173)
- [Aula 172: Padrões de projeto pt 01: Padrão Builder](#parte174)
- [Aula 173: Padrões de projeto pt 02: Padrão Singleton](#parte175)
- [Aula 174: Padrões de projeto pt 03: Padrão DAO](#parte176)
- [Aula 175: Padrões de projeto pt 04: Padrão Factory](#parte177)
- [Aula 176: Java 8 Parametrizando comportamentos](#parte178)
- [Aula 177: Java 8 Programação Funcional e Lambdas pt 01](#parte179)
- [Aula 178: Java 8 Programação Funcional e Lambdas pt 02](#parte180)
- [Aula 179: Java 8 Programação Funcional e Lambdas pt 03](#parte181)
- [Aula 180: Java 8 Programação Funcional e Lambdas pt 04 Method References](#parte182)
- [Aula 181: Java 8 Novas regras para Interfaces, métodos default](#parte183)
- [Aula 182: Java 8 Evitando NullPointerException com Optional pt 01](#parte184)
- [Aula 183: Java 8 Evitando NullPointerException com Optional pt 02](#parte185)
- [Aula 184: Java 8 Evitando NullPointerException com Optional pt 03](#parte186)
- [Aula 185: Java 8 Streams pt 01](#parte187)
- [Aula 185: Java 8 Streams pt 01](#parte188)
- [Aula 186: Java 8 Streams pt 02](#parte189)
- [Aula 187: Java 8 Streams pt 03, map e flatmap](#parte190)
- [Aula 188: Java 8 Streams pt 04, Finding and matching](#parte191)
- [Aula 189: Java 8 Streams pt 05, Streams especializados (Streams primitivos)](#parte192)
- [Aula 190: Java 8 Streams pt 06, Gerando Streams](#parte193)
- [Aula 191: Java 8 Streams pt 07, Reduzindo e sumarizando Streams](#parte194)
- [Aula 192: Java 8 Streams pt 08, Agrupando Streams](#parte195)
- [Aula 193: Java 8 Parallel Streams pt 01, Introdução aos streams paralelos](#parte196)
- [Aula 194: Java 8 Parallel Streams pt 02, Quando utilizar streams paralelos](#parte197)
- [Aula 195: Java 8 CompletableFuture pt 01, Introdução a programação assíncrona](#parte198)
- [Aula 196: Java 8 CompletableFuture pt 02, Funcionamento do CompletableFuture](#parte199)
- [Aula 197: Java 8 CompletableFuture pt 03, Tratamento de exceções assíncronas](#parte200)
- [Aula 198: Java 8 CompletableFuture pt 04, Desempenho comparado aos Streams](#parte201)
- [Aula 199: Java 8 CompletableFuture pt 05, CompletableFuture Custom Executor](#parte202)
- [Aula 200: Java 8 CompletableFuture pt 06, Encadeando tarefas pt 01](#parte203)
- [Aula 201: Java 8 CompletableFuture pt 07, Encadeando tarefas pt 02](#parte204)
- [Aula 202: Java 8 CompletableFuture pt 08, Exibindo resultados dinamicamente](#parte205)
- [Aula 203: Java 8 Nova API DateTime LocalDate, LocalTime, LocalDateTime](#parte206)
- [Aula 204: Java 8 Nova API DateTime Instant, Duration and Period](#parte207)
- [Aula 205: Java 8 Nova API Manipulando datas de forma relativa](#parte208)
- [Aula 206: Java 8 Nova API DateTime, Fazendo ajustes temporais com TimeAdjuster](#parte209)
- [Aula 207: Java 8 Nova API DateTime, Formatação e parse](#parte210)
- [Aula 208: Java 8 Nova API DateTime, Trabalhando com Time Zones](#parte211)
- [FIM DO MARATONA?](#parte212)






---

## <a name="parte1">Aula 00: Introdução ao curso</a>

Apresentação dos conteúdo:

[Vídeo aula 00](https://www.youtube.com/watch?v=kkOSweUhGZM)


[Voltar ao Índice](#indice)

---

## <a name="parte2">Aula 01: Como JAVA funciona</a>

[Vídeo aula 01](https://www.youtube.com/watch?v=DlZJw7TXj2g)

Resumo:

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/como-java-funciona.PNG?raw=true)

Outros Artigos:

[Como uma Java Virtual Machine escrita em Java funciona?](https://pt.stackoverflow.com/questions/178563/como-uma-java-virtual-machine-escrita-em-java-funciona)


[Voltar ao Índice](#indice)

---

## <a name="parte3">Aula 02: Como instalar JAVA no windows</a>

[Aula 02: Como instalar JAVA no windows](https://www.youtube.com/watch?v=TcqICLuUuyA)

[Java Platform, Standard Edition](http://www.oracle.com/technetwork/pt/java/javase/downloads/index.html)


[Voltar ao Índice](#indice)

---

## <a name="parte4"> Aula 03: Executando o processo de compilação manualmente</a>

[Aula 03: Executando o processo de compilação manualmente](https://www.youtube.com/watch?v=eV3mj1LOJqE)

Deitel:

Normalmente, existem cinco fases: editar, compilar, carregar, verificar e executar. Nós as discutiremos no contexto do Java SE 8 Development Kit ( JDK).

Fase 1: criando um programa

A Fase 1 consiste em editar um arquivo com um programa editor, muitas vezes conhecido simplesmente como um editor. Você digita um programa Java (em geral referido como código-fonte) utilizando o editor, faz quaisquer correções necessárias e salva o programa em um dispositivo de armazenamento secundário, como sua unidade de disco. Arquivos de código-fonte Java
recebem um nome que termina com a extensão .java, que indica um arquivo contendo código-fonte Java.

Fase 2: compilando um programa Java em bytecodes

Na Fase 2, utilize o comando javac (o compilador Java) para compilar um programa. Por exemplo, a fim de compilar um programa chamado Welcome.java, você digitaria:

```java
javac Welcome.java
```

na janela de comando do seu sistema (isto é, o Prompt do MS-DOS, no Windows, ou o aplicativo Terminal, no Mac OS X) ou em um
shell Linux (também chamado Terminal em algumas versões do Linux). Se o programa compilar, o compilador produz um arquivo
.class chamado Welcome.class que contém a versão compilada. IDEs tipicamente fornecem um item de menu, como Build ou
Make, que chama o comando javac para você. Se o compilador detectar erros, você precisa voltar para a Fase 1 e corrigi-los.

O compilador Java converte o código-fonte Java em bytecodes que representam as tarefas a serem executadas na fase de execução
(Fase 5). O Java Virtual Machine (JVM) — uma parte do JDK e a base da plataforma Java — executa bytecodes. A máquina
virtual (virtual machine — VM) é um aplicativo de software que simula um computador, mas oculta o sistema operacional e o
hardware subjacentes dos programas que interagem com ela. Se a mesma máquina virtual é implementada em muitas plataformas
de computador, os aplicativos escritos para ela podem ser utilizados em todas essas plataformas. A JVM é uma das máquinas virtuais
mais utilizadas. O .NET da Microsoft utiliza uma arquitetura de máquina virtual semelhante.

Diferentemente das instruções em linguagem de máquina, que são dependentes de plataforma (isto é, de hardware específico
de computador), instruções bytecode são independentes de plataforma. Portanto, os bytecodes do Java são portáveis — sem recompilar
o código-fonte, as mesmas instruções em bytecodes podem ser executadas em qualquer plataforma contendo uma JVM que
entende a versão do Java na qual os bytecodes foram compilados. A JVM é invocada pelo comando java. Por exemplo, para executar
um aplicativo Java chamado Welcome, você digitaria

```java
java Welcome
```

em uma janela de comando para invocar a JVM, que então iniciaria os passos necessários a fim de executar o aplicativo. Isso começa
a Fase 3. IDEs tipicamente fornecem um item de menu, como Run, que chama o comando java para você.

Fase 3: carregando um programa na memória

Na Fase 3, a JVM armazena o programa na memória para executá-lo — isso é conhecido como carregamento. O
carregador de classe da JVM pega os arquivos .class que contêm os bytecodes do programa e os transfere para a memória primária.
Ele também carrega qualquer um dos arquivos .class fornecidos pelo Java que seu programa usa. Os arquivos .class podem ser
carregados a partir de um disco em seu sistema ou em uma rede (por exemplo, sua faculdade local ou rede corporativa ou a internet).

Fase 4: verificação de bytecode

Na Fase 4, enquanto as classes são carregadas, o verificador de bytecode examina seus bytecodes para assegurar que eles são
válidos e não violam restrições de segurança do Java (Figura 1.9). O Java impõe uma forte segurança para certificar-se de que os
programas Java que chegam pela rede não danificam os arquivos ou o sistema (como vírus e worms de computador).

Fase 5: execução

Na Fase 5, a JVM executa os bytecodes do programa, realizando, assim, as ações especificadas por ele (Figura 1.10). Nas primeiras
versões do Java, a JVM era simplesmente um interpretador para bytecodes. A maioria dos programas Java executava lentamente,
porque a JVM interpretava e executava um bytecode de cada vez. Algumas arquiteturas modernas de computador podem executar várias
instruções em paralelo. Em geral, as JVMs atuais executam bytecodes utilizando uma combinação de interpretação e a chamada
compilação just in time ( JIT). Nesse processo, a JVM analisa os bytecodes à medida que eles são interpretados, procurando hot spots
(pontos ativos) — partes dos bytecodes que executam com frequência. Para essas partes, um compilador just in time (JIT), como o
compilador Java HotSpot™ da Oracle, traduz os bytecodes para a linguagem de máquina do computador subjacente. Quando a JVM
encontra de novo essas partes compiladas, o código de linguagem de máquina mais rápido é executado. Portanto, os programas Java
realmente passam por duas fases de compilação: uma em que o código-fonte é traduzido em bytecodes (para a portabilidade entre
JVMs em diferentes plataformas de computador) e outra em que, durante a execução, os bytecodes são traduzidos em linguagem de
máquina para o computador real no qual o programa é executado.

Um aplicativo Java é um programa de computador que é executado quando você utiliza o comando java para carregar a Java
Virtual Machine ( JVM).

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/welcome1java.PNG?raw=true)

Modifificando

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/welcome2java.PNG?raw=true)

outro exemplo:

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/welcome3java.PNG?raw=true)

Algumas sequências de escape comuns:

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/escapes.PNG?raw=true)

Outros:

[Processo de Interpretação e Compilação: Entendendo o java de uma forma diferente](http://www.devmedia.com.br/processo-de-interpretacao-e-compilacao-entendendo-o-java-de-uma-forma-diferente/24257)

[Alô Mundo: Entendendo o java de uma forma diferente](http://www.devmedia.com.br/alo-mundo-entendendo-o-java-de-uma-forma-diferente/24032)



[Voltar ao Índice](#indice)

---

## <a name="parte5">Aula 04: Download do ambiente de desenvolvimento</a>

[Aula 04: Download do ambiente de desenvolvimento](https://www.youtube.com/watch?v=blYNhqo7yhk)

Dois editores amplamente utilizados nos sistemas Linux são vi e emacs. O Windows fornece o Bloco de Notas. Já o OS X fornece
o TextEdit. Também há muitos editores freeware e shareware disponíveis on-line, incluindo Notepad++ (notepad-plus-plus.
org), EditPlus (www.editplus.com), TextPad (www.textpad.com) e jEdit (www.jedit.org).

Ambientes de desenvolvimento integrado (IDEs) fornecem ferramentas que suportam o processo de desenvolvimento de software,
como editores e depuradores para localizar erros lógicos (que fazem programas serem executados incorretamente) e outros.
Há muitos IDEs Java populares, incluindo:

- Eclipse (www.eclipse.org)
- NetBeans (www.netbeans.org)
- IntelliJ IDEA (www.jetbrains.com)

#### Palavras Reservadas JAVA:

Modificadores de acesso

- private: acesso apenas dentro da classe
- protected: acesso por classes no mesmo pacote e subclasses
- public: acesso de qualquer classe

Modificadores de classes, variáveis ou métodos

- abstract: classe que não pode ser instanciada ou método que precisa ser implementado por uma subclasse não abstrata
- class: especifica uma classe
- extends: indica a superclasse que a subclasse está estendendo
- final: impossibilita que uma classe seja estendida, que um método seja sobrescrito ou que uma variável seja reinicializada
- implements: indica as interfaces que uma classe irá implementar
- interface: especifica uma interface
- native: indica que um método está escrito em uma linguagem dependente de plataforma, como o C
- new: instancia um novo objeto, chamando seu construtor
- static: faz um método ou variável pertencer à classe ao invés de às instâncias
- strictfp: usado em frente a um método ou classe para indicar que os números de ponto flutuante seguirão as regras de ponto flutuante em todas as expressões
- synchronized:indica que um método só pode ser acessado por uma thread de cada vez
- transient: impede a serialização de campos
- volatile:indica que uma variável pode ser alterada durante o uso de threads

Controle de fluxo dentro de um bloco de código

- break: sai do bloco de codigo em que ele está
- case: executa um bloco de código dependendo do teste do switch
- continue: pula a execução do código que viria após essa linha e vai para a próxima passagem do loop
- default: executa esse bloco de codigo caso nenhum dos teste de switch-case seja verdadeiro
- do: executa um bloco de código uma vez, e então realiza um teste em conjunto com o while para determinar se o bloco deverá ser executado novamente
- else: executa um bloco de código alternativo caso o teste if seja falso
- for: usado para realizar um loop condicional de um bloco de código
- if: usado para realizar um teste lógico de verdadeiro o falso
- instanceof: determina se um objeto é uma instância de determinada classe, superclasse ou interface
- return: retorna de um método sem executar qualquer código que venha depois desta linha (também pode retornar uma variável)
- switch: indica a variável a ser comparada nas expressões case
- while: executa um bloco de código repetidamente enquanto a condição for verdadeira

Tratamento de erros

- assert: testa uma expressão condicional para verificar uma suposição do programador
- catch: declara o bloco de código usado para tratar uma exceção
- finally: bloco de código, após um try-catch, que é executado independentemente do fluxo de programa seguido ao lidar com uma exceção
- throw: usado para passar uma exceção para o método que o chamou
- throws: indica que um método pode passar uma exceção para o método que o chamou
- try: bloco de código que tentará ser executado, mas que pode causar uma exceção

Controle de pacotes

- import:importa pacotes ou classes para dentro do código
- package: especifica a que pacote todas as classes de um arquivo pertencem

Primitivos

- boolean: um valor indicando verdadeiro ou falso
- byte: um inteiro de 8 bits (signed)
- char: um caracter unicode (16-bit unsigned)
- double: um número de ponto flutuante de 64 bits (signed)
- float: um número de ponto flutuante de 32 bits (signed)
- int: um inteiro de 32 bits (signed)
- long: um inteiro de 64 bits (signed)
- short: um inteiro de 32 bits (signed)

Variáveis de referência

- super: refere-se a superclasse imediata
- this: refere-se a instância atual do objeto

Retorno de um método

- void: indica que o método não tem retorno

Palavras reservadas não utilizadas

- const: Não utilize para declarar constantes; use public static final
- goto: não implementada na linguagem Java por ser considerada prejudicial

Literais reservados

De acordo com a Java Language Specification, null, true e false são tecnicamente chamados de valores literais, e não keywords. 
Se você tentar criar algum identificador com estes valores, você também terá um erro de compilação.

FONTE:[As 52 palavras reservadas do Java](http://www.linhadecodigo.com.br/artigo/83/as-52-palavras-reservadas-do-java.aspx)

[Voltar ao Índice](#indice)

---

## <a name="parte6">Aula 05: Tipos primitivos, convenções de código e comentários</a>

[Aula 05: Tipos primitivos, convenções de código e comentários](https://www.youtube.com/watch?v=g-_NSf0e0z8)

```java
public class ImprimindoVariaveis {
    public static void main(String[] args) {
        int idadeDosPais = 50;
        System.out.println("A idade é "+idadeDosPais);
    }
}

```
Tipos primitivos Java:

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/tiposprimitivos.png?raw=true)



[Voltar ao Índice](#indice)

---

## <a name="parte7">Aula 06: Continuação tipos primitivos, exercício e operadores</a>

Exemplo 01:
```java
/**
 * Criado por José Stélio Malcher Jr. on 14/09/2017.
 */
public class RelatorioPendencia {
    public static void main(String[] args) {
        String nome = "Bulma";
        String endereco = "456 Rua saiadin";
        String telefone = "(91)98877-6655";

        System.out.println("O "+nome + " mora em "+endereco+ " e seu telefone é "+ telefone + ". (ok)");
    }
}

```

Exemplo 02:

```java
/**
 * Criado por José Stélio Malcher Jr. on 15/09/2017.
 */
public class Operadores {
    public static void main(String[] args) {
        int numero1 = 10;
        int numero2 = 20;
        System.out.println(numero1+numero2);
        System.out.println("A Soma é " + numero1+numero2);
        System.out.println(numero1+numero2 + "   SOMANDO...   " + numero1 + numero2);
        System.out.println(numero1+numero2 + "   SOMANDO...   " + (numero1 + numero2));
    }
}

```
Saída
```
30
A Soma é 1020
30   SOMANDO...   1020
30   SOMANDO...   30

```


[Voltar ao Índice](#indice)

---

## <a name="parte8">Aula 07: Operador resto e operadores de comparação</a>

Operador de módulo/resto
```java
    int numeroInteiro = 20;
        long numeroLong = 200000L;

        double numeroDouble = 10d;
        float numeroFloat = 20f;
        numeroFloat = (float) numeroDouble;

        int resto = 20 % 2;
        System.out.println("Resto é " + resto);
        System.out.println(numeroDouble);

```

Operadores de comparação

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/operadores-comparacao-java.png?raw=true)

```java
        boolean dezMaiorqueVinte = 10 >= 20;
        boolean dezMenorqueVinte = 10 <= 20;
        System.out.println(dezMaiorqueVinte);
        System.out.println(dezMenorqueVinte);
        System.out.println(5 == 5);
        System.out.println(5 != 5);
        
```
```java
false
true
true
false

Process finished with exit code 0
```

[Voltar ao Índice](#indice)

---

## <a name="parte9">Aula 08: Operadores Lógicos</a>

```java
        int idade = 18;
        float salario = 5000f;

        System.out.println(idade >= 21 && salario >= 2000);
        System.out.println(idade <= 16 && salario <= 2000);
        // false
        // false
        
        System.out.println(idade >= 21 || salario >= 2000);
        System.out.println(idade <= 21 || salario >= 2000);
        // true
        // true
```
![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/operadores-logicos.png?raw=true)

[Voltar ao Índice](#indice)

---

## <a name="parte10">Aula 09: Operadores de Atribuição</a>

Exemplo:
```java
        int salario = 2000;
        int numero = 11;

        numero %= 2;
        numero = numero % 2;
        System.out.println(numero);
```

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/atribuicao.PNG?raw=true)

### Precedência de Operadores

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/precedencia_operadores.png?raw=true)

Exemplo:

![Como java funciona](https://github.com/josemalcher/DevDojo-Maratona-Java/blob/master/img/precedencia_java_01.PNG?raw=true)

## Do livro Deitel 10

2.5 Outra aplicação: adicionando inteiros
```java
        Scanner input = new Scanner(System.in);

        int numero1;
        int numero2;
        int soma;

        System.out.println("Entre com o primeiro numero");
        numero1 = input.nextInt();

        System.out.println("Entre com o segundo numero");
        numero2 = input.nextInt();

        soma = numero1 + numero2;

        System.out.printf("A soma é %d%n", soma);
```

2.8 Tomada de decisão: operadores de igualdade e operadores relacionais
```java
        Scanner entrada = new Scanner(System.in);

        int num1, num2;

        System.out.println("Entre com o primeiro valor: ");
        num1 = entrada.nextInt();

        System.out.println("Entre com o segundo valor: ");
        num2 = entrada.nextInt();

        if(num1 == num2)
            System.out.printf("%d == %d%n",num1,num2);
        if(num1 != num2)
            System.out.printf("%d != %d%n",num1,num2);
        if(num1 < num2)
            System.out.printf("%d < %d%n",num1,num2);
        if(num1 > num2)
            System.out.printf("%d > %d%n",num1,num2);
        if(num1 <= num2)
            System.out.printf("%d <= %d%n",num1,num2);
        if(num1 >= num2)
            System.out.printf("%d >= %d%n",num1,num2);
```

### Resumo do Capítulo 2 Introdução a aplicativos Java – entrada/saída e operadores

Seção 2.2 Nosso primeiro programa Java: imprimindo uma linha de texto

- Um aplicativo Java é executado quando você usa o comando "java" para iniciar a JVM.
- Comentários documentam programas e melhoram sua legibilidade. O compilador ignora-os.
- Um comentário que começa com // é de fim de linha — ele termina no fim da linha em que aparece.
- Comentários tradicionais podem se estender por várias linhas e são delimitados por /*  e  */ .
- Os comentários da Javadoc, delimitados por /** e */, permitem que você incorpore a documentação do programa no código. O programa utilitário javadoc gera páginas em HTML com base nesses comentários.
- Um erro de sintaxe (também chamado erro de compilador, erro em tempo de compilação ou erro de compilação) ocorre quando o compilador encontra um código que viola as regras da linguagem do Java. É semelhante a um erro de gramática em um idioma natural.
- Linhas em branco, caracteres de espaço em branco e caracteres de tabulação são conhecidos como espaço em branco. O espaço em branco torna os programas mais fáceis de ler e não é ignorado pelo compilador.
- As palavras-chave são reservadas para uso pelo Java e sempre são escritas com todas as letras minúsculas.
- A palavra-chave class introduz uma declaração de classe.
- Por convenção, todos os nomes de classes em Java começam com uma letra maiúscula e apresentam a letra inicial de cada palavra que eles incluem em maiúscula (por exemplo, SampleClassName).
- O nome de uma classe Java é um identificador — uma série de caracteres consistindo em letras, dígitos, sublinhados ( _ ) e sinais de cifrão ($) que não iniciem com um dígito nem contenham espaços.
- O Java faz distinção entre maiúsculas e minúsculas.
- O corpo de cada declaração de classe é delimitado por chaves, { e }.
- Uma declaração de class public deve ser salva em um arquivo com o mesmo nome da classe seguido pela extensão “.java”.
- O método main é o ponto de partida de cada aplicativo Java e deve iniciar com
```java
    public static void main(String[] args)
```
Caso contrário, a JVM não executará o aplicativo.

- Os métodos realizam tarefas e retornam informações ao concluí-las. A palavra-chave void indica que um método executará uma tarefa, mas não retornará nenhuma informação.
- As instruções instruem o computador a realizar ações.
- Uma string entre aspas duplas é às vezes chamada de string de caracteres ou string literal.
- O objeto de saída padrão (System.out) exibe caracteres na janela de comando.
- O método System.out.println exibe seu argumento na janela de comando seguido por um caractere de nova linha para posicionar o cursor de saída no começo da próxima linha.
- Você compila um programa com o comando javac. Se o programa não contiver nenhum erro de sintaxe, um arquivo de classe contendo os bytecodes Java que representam o aplicativo é criado. Esses bytecodes são interpretados pela JVM quando executamos o programa.
- Para executar um aplicativo, digite java seguido pelo nome da classe que contém main.

Seção 2.3 Modificando nosso primeiro programa Java

- System.out.print exibe seu argumento e posiciona o cursor de saída imediatamente após o último caractere exibido.
- Uma barra invertida (\) em uma string é um caractere de escape. O Java combina-o com o próximo caractere para formar uma sequência de escape. A sequência de escape \n representa o caractere de nova linha.

Seção 2.4 Exibindo texto com printf

- O método System.out.printf (f significa “formatado”) exibe os dados formatados.
- O primeiro argumento do método printf é uma string de formato contendo especificadores de texto fixo e/ou de formato. Cada especificador de formato indica o tipo de dado a ser gerado e é um espaço reservado para um argumento correspondente que aparece após a string de formato.
- Especificadores de formato iniciam com um sinal de porcentagem (%) e são seguidos por um caractere que representa o tipo de dado. O especificador de formato %s é um espaço reservado para uma string de caracteres.
- O especificador de formato %n é um separador de linha portável. Você não pode usar %n no argumento para System.out.print ou System.out.println; mas o separador de linha gerado por System.out.println depois que ele exibe seu argumento é portável em diferentes sistemas operacionais.

Seção 2.5 Outra aplicação: adicionando inteiros

- Uma declaração import ajuda o compilador a localizar uma classe que é usada em um programa.
- O rico conjunto do Java de classes predefinidas é agrupado em pacotes — chamados de grupos de classes. Esses são referidos como biblioteca de classes Java, ou Interface de Programação de Aplicativo Java (API Java).
- Uma variável é uma posição na memória do computador na qual um valor pode ser armazenado para utilização posterior em um programa. Todas as variáveis devem ser declaradas com um nome e um tipo antes que possam ser utilizadas.
- O nome de uma variável permite que o programa acesse o valor dela na memória.
- Um Scanner (pacote java.util) permite que um programa leia os dados que utilizará. Antes de um Scanner poder ser utilizado, o programa deve criá-lo e especificar a origem dos dados.
- Variáveis devem ser inicializadas a fim de serem preparadas para uso em um programa.
- A expressão new Scanner(System.in) cria um Scanner que lê a partir do objeto de entrada padrão (System.in) — normalmente o teclado.
- O tipo de dado int é utilizado para declarar variáveis que conterão valores de inteiro. O intervalo de valores para um int é –2.147.483.648 a +2.147.483.647.
- Os tipos float e double especificam números reais com pontos decimais, como 3.4 e -11.19.
- Variáveis do tipo char representam caracteres individuais, como uma letra maiúscula (por exemplo, A), um dígito (por exemplo, 7), um caractere especial (por exemplo, * ou %) ou uma sequência de escape (por exemplo, tab, \t).
- Tipos como int, float, double e char são primitivos. Os nomes dos tipos primitivos são palavras-chave; portanto, todos devem aparecer em letras minúsculas.
- Um prompt direciona o usuário a tomar uma ação específica.
- O método Scanner nextInt obtém um inteiro para uso em um programa.
- O operador de atribuição, =, permite ao programa atribuir um valor a uma variável. Ele é chamado operador binário, porque tem dois operandos.
- Partes das declarações que contêm valores são chamadas expressões.
- O especificador de formato %d é um marcador de lugar para um valor int.

Seção 2.6 Conceitos de memória

- Os nomes de variável correspondem a posições na memória do computador. Cada variável tem um nome, um tipo, um tamanho e um valor.
- Um valor que é colocado em uma posição de memória substitui o valor anterior dessa posição, que é perdido.

Seção 2.7 Aritmética

- Os operadores aritméticos são + (adição), - (subtração), * (multiplicação), / (divisão) e % (resto).
- A divisão de inteiros produz um quociente com inteiros.
- O operador de resto, %, fornece o resto depois da divisão.
- As expressões aritméticas devem ser escritas em forma de linha reta.
- Se uma expressão contém parênteses aninhados, o conjunto mais interno é avaliado primeiro.
- O Java aplica os operadores a expressões aritméticas em uma sequência precisa determinada pelas regras de precedência de operador.
- Quando dizemos que operadores são aplicados da esquerda para a direita, estamos nos referindo à sua associatividade. Alguns operadores associam da direita para a esquerda.
- Parênteses redundantes podem tornar uma expressão mais clara.

Seção 2.8 Tomada de decisão: operadores de igualdade e operadores relacionais

- A instrução if toma uma decisão baseada no valor de uma condição (verdadeiro ou falso).
- As condições em instruções if podem ser formadas utilizando-se os operadores de igualdade (== e !=) e relacionais (>, <, >= e <=).
- Uma instrução if começa com a palavra-chave if, seguida por uma condição entre parênteses, e espera uma instrução no seu corpo.
- A instrução vazia é do tipo que não realiza qualquer tarefa.

[Voltar ao Índice](#indice)

---

## <a name="parte11">Aula 10: Controle de fluxo if, else if e else</a>

Exemplo aula 10:
```java
        // idade < 15 cat infantil
        // idade >= 15 && idade < 18 Ccat juvenil
        // idade >= 18 cat adulto

        int idade = 18;
        String categoria;

        if(idade < 15){
            categoria = "infantil";
        }else if(idade >=15 && idade < 18){
            categoria = "Juvenil";
        }else{
            categoria = "Adulto";
        }
        System.out.println(categoria);
```

[Voltar ao Índice](#indice)

---

## <a name="parte12">Aula 11: Controle de fluxo: Tabela verdade e mais.</a>


O Java fornece o operador condicional (?:), que pode ser utilizado no lugar de uma instrução if...else. Isso pode tornar o código mais curto e mais claro. O operador condicional é o único operador ternário do Java (isto é, um operador que recebe três operandos). Juntos, os operandos e o símbolo ?: formam uma expressão condicional. O primeiro operando (à esquerda do ?) é uma expressão boolean (isto é, uma condição que é avaliada como um valor boolean — true ou false), o segundo operando (entre o ? e :) é o valor da expressão condicional se a expressão boolean for true e o terceiro operando (à direita do :) é o valor da expressão condicional se a expressão boolean for avaliada como false.

Exemplo: Operador ternario
```java
        int idade = 15;
        String status;

        status = idade < 18 ? "Não Adulto" : "Adulto";
        System.out.println(status);
```

Tabela Verdade

```java
// create truth table for && (conditional AND) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n%s: %b%n%s: %b%n%n",
                "Conditional AND (&&)", "false && false", (false && false),
                "false && true", (false && true),
                "true && false", (true && false),
                "true && true", (true && true));

        // create truth table for || (conditional OR) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n%s: %b%n%s: %b%n%n",
                "Conditional OR (||)", "false || false", (false || false),
                "false || true", (false || true),
                "true || false", (true || false),
                "true || true", (true || true));

        // create truth table for & (boolean logical AND) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n%s: %b%n%s: %b%n%n",
                "Boolean logical AND (&)", "false & false", (false & false),
                "false & true", (false & true),
                "true & false", (true & false),
                "true & true", (true & true));

        // create truth table for | (boolean logical inclusive OR) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n%s: %b%n%s: %b%n%n",
                "Boolean logical inclusive OR (|)",
                "false | false", (false | false),
                "false | true", (false | true),
                "true | false", (true | false),
                "true | true", (true | true));

        // create truth table for ^ (boolean logical exclusive OR) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n%s: %b%n%s: %b%n%n",
                "Boolean logical exclusive OR (^)",
                "false ^ false", (false ^ false),
                "false ^ true", (false ^ true),
                "true ^ false", (true ^ false),
                "true ^ true", (true ^ true));

        // create truth table for ! (logical negation) operator
        System.out.printf("%s%n%s: %b%n%s: %b%n", "Logical NOT (!)",
                "!false", (!false), "!true", (!true));
```

```java
Conditional AND (&&)
false && false: false
false && true: false
true && false: false
true && true: true

Conditional OR (||)
false || false: false
false || true: true
true || false: true
true || true: true

Boolean logical AND (&)
false & false: false
false & true: false
true & false: false
true & true: true

Boolean logical inclusive OR (|)
false | false: false
false | true: true
true | false: true
true | true: true

Boolean logical exclusive OR (^)
false ^ false: false
false ^ true: true
true ^ false: true
true ^ true: false

Logical NOT (!)
!false: true
!true: false
```



[Voltar ao Índice](#indice)

---

## <a name="parte13">Aula 12: Controle de fluxo Resolução do exercício if else</a>

Exercício:
```java
public class ExercicioControledeFluxo {
    public static void main(String[] args) {
        /*
        Crie uma variavel salario e imprima seu imposto
        imposto:
            salario < 1000 5%
            salario >= 1000 && salario < 2000 10%
            salario >= 2000 && salario < 4000 15%
            salario > 5000 20%
         */

        double salario = 2000;
        double totalImposto = 0 ;
        if(salario <= 1000){
            System.out.println("entrou 1");
            totalImposto = salario * 0.05;
        }else if(salario>= 1000 && salario < 2000){
            System.out.println("entrou 2");
            totalImposto = salario * 0.1;
        }else if(salario>= 2000 && salario < 4000){
            totalImposto = salario * 0.15;
        }else{
            totalImposto = salario * 0.2;
        }
        System.out.println("O total de imposto e: " + totalImposto);
    }
}

```

[Voltar ao Índice](#indice)

---

## <a name="parte14"> </a>

[Voltar ao Índice](#indice)

---

## <a name="parte15"> </a>

[Voltar ao Índice](#indice)

---

## <a name="parte16"> </a>

[Voltar ao Índice](#indice)

---

## <a name="parte17"> </a>

[Voltar ao Índice](#indice)

---

## <a name="parte96"></a>


[Voltar ao Índice](#indice)

---